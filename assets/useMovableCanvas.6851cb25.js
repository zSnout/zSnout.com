var G=Object.defineProperty,V=Object.defineProperties;var Z=Object.getOwnPropertyDescriptors;var Y=Object.getOwnPropertySymbols;var F=Object.prototype.hasOwnProperty,H=Object.prototype.propertyIsEnumerable;var I=(t,n,e)=>n in t?G(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,P=(t,n)=>{for(var e in n||(n={}))F.call(n,e)&&I(t,e,n[e]);if(Y)for(var e of Y(n))H.call(n,e)&&I(t,e,n[e]);return t},D=(t,n)=>V(t,Z(n));import{ac as v,u as a,aj as A,k as h,a8 as B,r as J,j as N,ad as K}from"./index.19bd37b3.js";import{u as Q}from"./useWebGL.96801f7d.js";import{s as $}from"./useOption.2380319c.js";function X(t,n,e,l,r){return v(()=>(a(r)-a(t))*(a(l)-a(e))/(a(n)-a(t))+a(e))}function M(t,n,e){const l=A(),r=X(0,l.width,0,1,e.x),u=X(l.height,0,0,1,e.y);return{x:v(()=>r.value*n.x.value+t.x.value),y:v(()=>u.value*n.y.value+t.y.value)}}function ee(t,n){const e=A();t=te(t,n);const l=v(()=>{const r=a(t.xStart),u=a(t.xEnd),y=a(t.yStart),x=a(t.yEnd);return e.width.value>e.height.value?{x:(r-(u-r)/2)/2,y}:{x:r,y:(y-(x-y)/2)/2}});return{offset:{x:v(()=>l.value.x),y:v(()=>l.value.y)},scale:{x:v(()=>a(t.xEnd)-a(t.xStart)),y:v(()=>a(t.yEnd)-a(t.yStart))}}}function j(t){return v(()=>[a(t.x),a(t.y)])}function te(t,n){const e=v(()=>{const{xStart:l,xEnd:r,yStart:u,yEnd:y}=t,x=a(l)+a(r),c=a(u)+a(y),d=(a(r)-a(l))/2,s=(a(y)-a(u))/2;let{width:{value:o},height:{value:f}}=n;return(Number.isNaN(o)||o===0)&&(o=f),(Number.isNaN(f)||f===0)&&(f=o),(Number.isNaN(o)||o===0)&&(o=f=1),o<f?{xStart:l,xEnd:r,yStart:c-f/o*s,yEnd:c+f/o*s}:{xStart:x-o/f*d,xEnd:x+o/f*d,yStart:u,yEnd:y}});return{xStart:v(()=>a(e.value.xStart)),xEnd:v(()=>a(e.value.xEnd)),yStart:v(()=>a(e.value.yStart)),yEnd:v(()=>a(e.value.yEnd))}}const _=`
struct Bounds {
  float xStart;
  float xEnd;
  float yStart;
  float yEnd;
};

struct Coordinates {
  float x;
  float y;
};
`,ae=`
in vec2 _pos;
out vec2 pos;

uniform vec2 offset;
uniform vec2 scale;

void main() {
  gl_Position = vec4(_pos, 0, 1);
  pos = _pos * scale + offset;
}`;async function ne(t,n,e){var x,c,d,s,o,f,g,p,C;const l={xStart:h((c=(x=e==null?void 0:e.bounds)==null?void 0:x.xStart)!=null?c:-2),xEnd:h((s=(d=e==null?void 0:e.bounds)==null?void 0:d.xEnd)!=null?s:2),yStart:h((f=(o=e==null?void 0:e.bounds)==null?void 0:o.yStart)!=null?f:-2),yEnd:h((p=(g=e==null?void 0:e.bounds)==null?void 0:g.yEnd)!=null?p:2)},r=await Q(t,_+n,D(P({},e),{vertShader:_+((C=e==null?void 0:e.vertShader)!=null?C:ae)})),{offset:u,scale:y}=ee(l,r.size);if(r.useUniform("offset","f",j(u)),r.useUniform("scale","f",j(y)),(e==null?void 0:e.uniforms)===!0){r.useUniform("bounds.xStart","f",l.xStart),r.useUniform("bounds.xEnd","f",l.xEnd),r.useUniform("bounds.yStart","f",l.yStart),r.useUniform("bounds.yEnd","f",l.yEnd);const E=B(),S=M(u,y,E);r.useUniform("pointer.x","f",S.x),r.useUniform("pointer.y","f",S.y)}return Object.assign(r,{bounds:l,offset:u,scale:y})}function re(){const t=J(new Map);return N("pointermove",n=>{const{height:e,pointerId:l,pointerType:r,pressure:u,tiltX:y,tiltY:x,twist:c,width:d,x:s,y:o}=n;!t.has(l)||t.set(l,{height:e,pointerId:l,pointerType:r||null,pressure:u,tiltX:y,tiltY:x,twist:c,width:d,x:s,y:o})}),N("pointerdown",n=>{const{height:e,pointerId:l,pointerType:r,pressure:u,tiltX:y,tiltY:x,twist:c,width:d,x:s,y:o}=n;t.set(l,{height:e,pointerId:l,pointerType:r||null,pressure:u,tiltX:y,tiltY:x,twist:c,width:d,x:s,y:o})}),N("pointerup",n=>{t.delete(n.pointerId)}),N("pointercancel",n=>{t.delete(n.pointerId)}),t}function ue(t,n=1e6){return v({get(){return~~(a(n)*t.value)/a(n)},set(e){t.value=e}})}function b(t,n,e){return{xStart:v(()=>a(t.xStart)+a(e)*(a(n.x)-a(t.xStart))/10),xEnd:v(()=>a(t.xEnd)+a(e)*(a(n.x)-a(t.xEnd))/10),yStart:v(()=>a(t.yStart)+a(e)*(a(n.y)-a(t.yStart))/10),yEnd:v(()=>a(t.yEnd)+a(e)*(a(n.y)-a(t.yEnd))/10)}}async function ye(t,n,e){const l=await ne(t,n,e),{canvas:r,bounds:u,offset:y,onDispose:x,scale:c,useUniform:d}=l,s=B(),o={x:h(NaN),y:h(NaN)},f=h(0),g=b(u,M(y,c,s),f);if((e==null?void 0:e.uniforms)===!0){const i=b(u,M(y,c,s),1);d("zoomRegion.xStart","f",i.xStart),d("zoomRegion.xEnd","f",i.xEnd),d("zoomRegion.yStart","f",i.yStart),d("zoomRegion.yEnd","f",i.yEnd)}x(N(r,"wheel",i=>{i.preventDefault(),s.x.value=i.offsetX,s.y.value=i.offsetY,f.value=Math.sqrt(Math.abs(i.deltaY))*-Math.sign(i.deltaY)/10;const{xStart:{value:w},xEnd:{value:U},yStart:{value:z},yEnd:{value:T}}=g;u.xStart.value=w,u.xEnd.value=U,u.yStart.value=z,u.yEnd.value=T},{passive:!1}));const p=M(y,c,s),C=M(y,c,o),E={x:h(NaN),y:h(NaN)},S={x:h(NaN),y:h(NaN)};x(N(r,"pointermove",i=>{if(i.preventDefault(),m.value&&!isNaN(E.x.value)&&!isNaN(S.x.value)){const z=Math.hypot(S.x.value-E.x.value,S.y.value-E.y.value);E.x.value=m.value[0].x,E.y.value=m.value[0].y,S.x.value=m.value[1].x,S.y.value=m.value[1].y;const T=Math.hypot(S.x.value-E.x.value,S.y.value-E.y.value);s.x.value=(E.x.value+S.x.value)/2,s.y.value=(E.y.value+S.y.value)/2,f.value=T>=z?.4:-.4;const{xStart:{value:O},xEnd:{value:W},yStart:{value:k},yEnd:{value:q}}=g;u.xStart.value=O,u.xEnd.value=W,u.yStart.value=k,u.yEnd.value=q;return}else if(m.value){E.x.value=m.value[0].x,E.y.value=m.value[0].y,S.x.value=m.value[1].x,S.y.value=m.value[1].y;return}if(Number.isNaN(o.x.value)||Number.isNaN(o.y.value))return;s.x.value=i.offsetX,s.y.value=i.offsetY;const w=p.x.value-C.x.value,U=p.y.value-C.y.value;u.xStart.value-=w,u.xEnd.value-=w,u.yStart.value-=U,u.yEnd.value-=U,o.x.value=s.x.value,o.y.value=s.y.value})),x(N(r,"pointerdown",i=>{r.setPointerCapture(i.pointerId),o.x.value=i.offsetX,o.y.value=i.offsetY})),x(N("pointerup",i=>{r.releasePointerCapture(i.pointerId),o.x.value=NaN,o.y.value=NaN}));const L=re(),m=v(()=>{const i=[...L.values()].filter(w=>w.pointerType=="touch");if(i.length===2)return i});function R(i){x($(i,ue(K(u,i))))}return R("xStart"),R("xEnd"),R("yStart"),R("yEnd"),l}export{ye as a,ue as u};
